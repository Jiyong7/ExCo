
# -*- coding: utf-8 -*-

##  FILE DESCRIPTION:
##      Normal module with a special name that holds custom user functions/variables.
##      To manipulate the editors/windows, take a look at the QScintilla details at:
##      http://pyqt.sourceforge.net/Docs/QScintilla2
##
##  NOTES:
##      Built-in special function escape sequence: "lit#"
##          (prepend it to escape built-ins like: cmain, set_all_text, lines, ...)

import os
import re
import ast
import operator
import data #These imports are optional, I added them here for clarity
import functions #These imports are optional, I added them here for clarity
import settings #These imports are optional, I added them here for clarity
import helper_forms
from forms import * #Imported for less typing

# Initialization function that gets executed only ONCE at startup
def first_scan():
    pass

data.tab_width = 4
data.terminal = "xterm"
data.edge_marker_column = 80
data.zoom_factor = 0
data.tree_display_font_size = 10
form.repl_helper.zoomTo(data.zoom_factor)

#Custom keyboard shortcuts
data.copy_keys = 'Ctrl+C'

def rename_items_in_directory(search_string,
                              replace_string,
                              regex=False,
                              directory=None):
    """
    Replace the search string in the file names in the selected directory
    """
    if directory == None:
        #'form' is a reference to the MainWindow object that contains useful functions
        directory = form._get_directory_with_dialog()
        if directory == "" or directory == None:
            print("Canceled")
            return
    dir = os.listdir(directory)
    if regex == False:
        for item in dir:
            if search_string in item:
                os.rename(
                    os.path.join(directory, item), 
                    os.path.join(directory, item.replace(search_string, replace_string))
                )
    else:
        compiled_re = re.compile(search_string)
        for item in dir:
            full_file_name = os.path.join(directory, item)
            replaced_name = re.sub(compiled_re, replace_string, full_file_name)
            if replaced_name != full_file_name:
                os.rename(full_file_name, replaced_name)
    print("DONE")
#Custom autocompletion
rename_items_in_directory.autocompletion = "rename_items_in_directory(\"search_string\",\"replace_string\",regex=False,directory=None)"


def delete_files_in_dir(extension=None, directory=None):
    """
    Delete all files with the selected file extension from the directory
    """
    if isinstance(extension, str) == False:
        print("File extension argument must be a string!")
        return
    if directory == None:
        directory = os.getcwd()
    elif os.path.isdir(directory) == False:
        return
    print("Deleting '{:s}' files in:".format(extension))
    print(directory)
    for file in os.listdir(directory):
        file_extension = os.path.splitext(file)[1].lower()
        if file_extension == extension or file_extension == "." + extension:
            os.remove(os.path.join(directory, file))
            print(" - deleted file: {:s}".format(file))
    print("DONE")
#Custom autocompletion
delete_files_in_dir.autocompletion = "delete_files_in_dir(extension=\"\", directory=None)"

        
def is_number(string):
    """Check if the string is a number (integer or float)"""
    try: 
        float(string)
        return True
    except ValueError:
        return False

def convert_to_4x_indentation(editor):
    """Convert indentation of a editor window to the 4-spaces convention"""
    line_list           = editor.line_list
    standard_spacing    = 4
    #Find the lowest indentation in the document
    base_spacing = 4
    for line in line_list:
        current_indentation = get_line_indentation(line)
        if current_indentation > 0 and current_indentation < base_spacing:
            base_spacing = current_indentation
    #Correct the spacing
    output_list = []
    for line in line_list:
        current_indentation = get_line_indentation(line)
        if current_indentation > 0:
            factor = current_indentation / base_spacing
            output_list.append(
                (int(factor * standard_spacing) * " ") + line[current_indentation:]
            )
        else:
            output_list.append(line)
    #Replace the line list in the editor with the new list
    editor.line_list = output_list
#Custom autocompletion
convert_to_4x_indentation.autocompletion = "convert_to_4x_indentation(cmain)"
    
def print_nim_forward_declarations():
    """
    Create and display the forward declarations for procedures/functions
    for the Nim programming language in the REPL MESSAGES tab
    """
    #Set the editor
    editor = cmain
    #Get the Nim nodes
    nim_nodes = functions.get_nim_node_tree(editor.text())
    #Check if forward declarations are needed
    if nim_nodes.procedures == []:
        form.display.repl_display_message(
            "No procedures in the document!", 
            message_type=global_module.MessageType.WARNING
        )
        return
    #Create the forward declarations
    forward_declerations = []
    for proc in nim_nodes.procedures:
        proc_name   = proc.name
        parameters  = ", ".join(proc.parameters)
        return_type = ""
        if proc.return_type != None:
            return_type = ": {:s}".format(proc.return_type)
        fd = "proc {:s}({:s}){:s}".format(proc_name, parameters, return_type)
        forward_declerations.append(fd)
    #Sort the declarations by name
    forward_declerations.sort()
    #Display the declarations
    form.display.repl_display_message(
        "namespace ForwardDeclarations:", 
        message_type=global_module.MessageType.SUCCESS
    )
    for declaration in forward_declerations:
        form.display.repl_display_message("    " + declaration)
#Custom autocompletion
print_nim_forward_declarations.autocompletion = "print_nim_forward_declarations()"

def xml_lexer_colors(html="black", tag="blue", attribute="red", single_string="magenta"):
    lexer = cmain.lexer()
    lexer.setColor(PyQt4.QtGui.QColor(html),0)
    lexer.setFont(PyQt4.QtGui.QFont('Courier', 10, weight=PyQt4.QtGui.QFont.Bold), 0)
    
    lexer.setColor(PyQt4.QtGui.QColor(tag),1)
    lexer.setFont(PyQt4.QtGui.QFont('Courier', 10, weight=PyQt4.QtGui.QFont.Bold), 1)
    
    lexer.setColor(PyQt4.QtGui.QColor(attribute),3)
    lexer.setFont(PyQt4.QtGui.QFont('Courier', 10, weight=PyQt4.QtGui.QFont.Bold), 3)
    
    lexer.setColor(PyQt4.QtGui.QColor(single_string),6)
    lexer.setFont(PyQt4.QtGui.QFont('Courier', 10, weight=PyQt4.QtGui.QFont.Bold), 6)
#Custom autocompletion
xml_lexer_colors.autocompletion = "xml_lexer_colors(html=\"black\", tag=\"blue\", attribute=\"red\", single_string=\"magenta\")"

def trim_whitespace():
    """Remove whitespace from back of every line in the main document"""
    ll = []
    for line in cmain.line_list:
        ll.append(line.rstrip())
    cmain.line_list = ll
trim_whitespace.autocompletion = "trim_whitespace()"
    
def align_indentation_to_cursor():
    """
    Align indentation of multiple lines to cursor, while keeping
    the current leading whitespace structure
    """
    start_line_number   = cmain.getSelection()[0] + 1
    end_line_number     = cmain.getSelection()[2] + 1
    smallest_line_space = 0
    #Get smallest indentation level
    for i in range(start_line_number, end_line_number+1):
        current_line_space = 0
        for char in line_list[i]:
            if char == " ":
                current_line_space += 1
            else:
                break
        if current_line_space < smallest_line_space or smallest_line_space == 0:
            smallest_line_space = current_line_space
    #Remove the smallest indentation level from selected lines
    new_lines = []
    for i in range(start_line_number, end_line_number+1):
        new_lines.append(line_list[i][smallest_line_space:])
    #Add the whitspaces to the current cursor position to every selected line_count
    padding = " " * cmain.getCursorPosition()[1]
    for i in range(0, len(new_lines)):
        new_lines[i] = padding + new_lines[i]
    #Finally, replace the lines
    line_list[start_line_number:end_line_number] = new_lines
align_indentation_to_cursor.autocompletion = "align_indentation_to_cursor()"

def align_nim_type_declerations():
    """Align indentation of Nim programming language type declarations"""
    start_line_number   = cmain.getSelection()[0] + 1
    end_line_number     = cmain.getSelection()[2] + 1
    line_indentation    = 0
    #Find indentation level by using the first line
    common_indentation = " " * (len(line_list[start_line_number]) - len(line_list[start_line_number].lstrip()))
    #Get largest indentation level between the var name and type
    largest_item_column = 0
    for i in range(start_line_number, end_line_number+1):
        split_line = line_list[i].split(":")
        #Check line structure
        if len(split_line) < 2:
            form.display.repl_display_message(
                "Inconsistent line structure in line: {:d}".format(i), 
                message_type=global_module.MessageType.ERROR
            )
            return
        elif not(":" in line_list[i]):
            form.display.repl_display_message(
                "Colon has to be right behind the variable name in line: {:d}".format(i), 
                message_type=global_module.MessageType.ERROR
            )
            return
        current_item_column = len(common_indentation) + len(split_line[0].strip()) + len(": ")
        if current_item_column > largest_item_column:
            largest_item_column = current_item_column
    #Pad all lines to the largest second item column
    replacement_list = []
    for i in range(start_line_number, end_line_number+1):
        split_line = line_list[i].split(":")
        colon_index = line_list[i].find(":") + 1
        line_beginning = (common_indentation + split_line[0].strip() + ": ").ljust(largest_item_column)
        line_end = line_list[i][colon_index:].lstrip()
        replacement_list.append(line_beginning + line_end)
    #Replace the range
    line_list[start_line_number:end_line_number] = replacement_list
align_nim_type_declerations.autocompletion = "align_nim_type_declerations()"

def NEP1():
    """Python/C to Nim coding convention conversion"""
    try:
        text = cmain.selectedText()
        if len(text.split("_")) < 2:
            return
        split_text = text.split("_")
        split_text[0] = split_text[0].lower()
        if split_text[0].startswith("py") and len(split_text[0]) > 2:
            split_text[0] = split_text[0][:2] + split_text[0][2].upper() + split_text[0][3:]
        if len(split_text) > 1:
            for i in range(1, len(split_text)):
                split_text[i] = split_text[i][0].upper() + split_text[i][1:]
        replacement = "".join(split_text)
        if replacement.startswith("py"):
            replacement = replacement[2].lower() + replacement[3:]
        result = "{{.deprecated: [{:s}: {:s}].}}".format(text, replacement)
        replace_in_selection(text,replacement,case_sensitive=True,window_name="Main")
#        line_list.insert(cmain.get_line_number()+1, "  " + result)
    except Exception as ex:
        print(str(ex))
#    cmain.set_first_visible_line(cmain.get_line_number()-20)
    print(result)
NEP1.autocompletion = "NEP1()"

def NEP1_proc():
    """Python/C to Nim coding convention conversion for procedures"""
    fr = cmain.getSelection()[0] + 1
    to = cmain.getSelection()[2] + 2
    if fr > to:
        temp_1 = fr
        temp_2 = to
        fr = temp_2
        to = remp_1
    try:
        ll = []
        for i in range(fr, to):
            if line_list[i].strip().startswith("#"):
                continue
            text = cmain.line_list[i]
            if len(text.split("_")) < 2 or not text.startswith("proc"):
                return
            proc_name = text[5:text.find("*(")]
            split_text = proc_name.split("_")
#            split_text[0] = split_text[0].lower()
            split_text[0] = split_text[0][0].lower() + split_text[0][1:]
            if split_text[0].startswith("py") and len(split_text[0]) > 2:
                split_text[0] = split_text[0][:2] + split_text[0][2].upper() + split_text[0][3:]
            if len(split_text) > 1:
                for j in range(1, len(split_text)):
                    split_text[j] = split_text[j][0].upper() + split_text[j][1:]
            replacement = "".join(split_text)
            if replacement.startswith("py"):
                replacement = replacement[2].lower() + replacement[3:]
#            print(proc_name + " > " + replacement)
            result = text.replace(proc_name, replacement)
            result = result.replace("importc,", 'importc: "{:s}"'.format(proc_name))
            cmain.line_list[i] = result
#            ll.append(result)
#            ll.append("{{.deprecated: [{:s}: {:s}].}}".format(proc_name, replacement))
        # Replace the modified lines
#        cmain.line_list.insert(to, "\n".join(ll))
    except Exception as ex:
        print(str(ex))
NEP1.autocompletion = "NEP1_proc()"

def NEP1_lines():
    """Python/C to Nim coding convention conversion for multiple lines"""
    if cmain.getSelection() != (-1,-1,-1,-1):
        fr = cmain.getSelection()[0] + 1
        to = cmain.getSelection()[2] + 2
        if fr > to:
            temp_1 = fr
            temp_2 = to
            fr = temp_2
            to = remp_1
        for i in range(fr, to):
            if line_list[i].strip().startswith("#"):
                continue
            cmain.setSelection(i-1,2,i-1,line_list[i].find("*"))
#            cmain.setSelection(i-1,2,i-1,line_list[i].find(" = cast"))
            NEP1()
    else:
        i = cmain.getCursorPosition()[0] + 1
        cmain.setSelection(i-1,2,i-1,line_list[i].find("*"))
#        cmain.setSelection(i-1,2,i-1,line_list[i].find(" = cast"))
        NEP1()
NEP1_lines.autocompletion = "NEP1_lines()"

def parse_python_code(text):
    """Parse and display relevant python data"""
    if text == "":
        form.display.repl_display_message(
            "No text to parse!", 
            message_type=data.MessageType.ERROR
        )
        return
    try:
        parsed_string = ast.parse(text)
    except:
        form.display.repl_display_message(
            "Error parsing the code!", 
            message_type=data.MessageType.ERROR
        )
        return
    nodes = [node for node in ast.walk(parsed_string)]
    #Get import/import_from nodes, combine them into one list and sort them
    import_nodes        = [(node.names[0].name, node.lineno) for node in nodes if isinstance(node, ast.Import)]
    importfrom_nodes    = [(node.module, node.lineno) for node in nodes if isinstance(node, ast.ImportFrom)]
    import_nodes.extend(importfrom_nodes)
    import_nodes.sort(key=operator.itemgetter(0))
    # Reinitialize the node lists
    class_nodes = []
    function_nodes = []
    all_vars = []
    #Other nodes
    class_nodes         = [node for node in nodes if isinstance(node, ast.ClassDef)]
    function_nodes      = [node for node in nodes if isinstance(node, ast.FunctionDef)]
    all_vars            = list(set([node.id for node in nodes if isinstance(node, ast.Name)]))
    all_vars.sort()
    for i in all_vars:
        print(i)
parse_python_code.autocompletion = "parse_python_code()"

def qscintilla_style_extract(low, high):
    ll = []
    styles = []
    for i in range(low, high):
        line = line_list[i].strip()
        if not(line.startswith("/") or line== ""):
            ident = line.split("=")[0].strip()
            ll.append("        " + line.replace("=", ":").replace(ident, "\"{0}\"".format(ident)))
            styles.append(line[:line.find("=")].strip())

    text = "    styles = {\n"
    text += "\n".join(ll)
    text += "\n    }"

    text += """
        def set_theme(self, theme):
            def set_color(color, style):
                self.setColor(
                    color, 
                    self.styles[style]
                )
            # Papers
            for i in self.styles:
                if i == "UnclosedString":
                    self.setPaper(theme.Paper.UNCLOSED_STRING, self.styles[i])
                else:
                    self.setPaper(theme.Paper.DEFAULT, self.styles[i])
            # Fonts
    """
    for i in styles:
        text += "        set_color(theme.Font.DEFAULT, \"{0}\")\n".format(i)

    cupper.setText(text)

def qscintilla_list_colors():
#    style_colors = {}
#    for i in PyQt4.Qsci.__dict__:
#        if i.startswith("QsciLexer") and len(i) > len("QsciLexer"):
#            if i != "QsciLexerCustom":
#                lexer_name = i.replace("QsciLexer", "")
#                cls = getattr(PyQt4.Qsci, i)
#                for j in dir(cls):
#                    att_value = getattr(cls, j)
#                    if j[0].isupper() == True and isinstance(att_value, int):
#                        styles[j] = att_value
#                for style in styles:
#                    obj = cls()
#                    color = hex(obj.defaultColor(styles[style]).rgb())
#                    #print("    {0} : {1}".format(style, color))
#                    if not(style in style_colors):
#                        style_colors[style] = color
#    a = list(style_colors.keys())
#    a.sort()
#    for i in a:
#        print("{0} = PyQt4.QtGui.QColor({1})".format(i.upper(), style_colors[i]))
    langs = {}
    for i in PyQt4.Qsci.__dict__:
        if i.startswith("QsciLexer") and len(i) > len("QsciLexer"):
            if i != "QsciLexerCustom":
                styles = {}
                lexer_name = i.replace("QsciLexer", "")
                cls = getattr(PyQt4.Qsci, i)
                for j in dir(cls):
                    style_value = getattr(cls, j)
                    if j[0].isupper() == True and isinstance(style_value, int):
                        styles[j] = style_value
                for style in styles:
                    obj = cls()
                    color = hex(obj.defaultColor(styles[style]).rgb())
                    paper = hex(obj.defaultPaper(styles[style]).rgb())
                    styles[style] = (style, styles[style] , color, paper)
                langs[lexer_name] = styles
#    print(langs["Python"])
#    print("class Paper:")
#    for lang in sorted(langs):
#        print("    class {0}:".format(lang))
#        for style in langs[lang]:
#            print("        {0} = \"{1}\"".format(langs[lang][style][0], langs[lang][style][3]))
#        print("    ")
    print("class Font:")
    for lang in sorted(langs):
        print("    class {0}:".format(lang))
        for style in sorted(langs[lang]):
            print("        {0} = \"{1}\"".format(langs[lang][style][0], langs[lang][style][2]))
        print("    ")

def qscintilla_check_lexers():
    import lexers
    for item in dir(lexers):
        if item[0].isupper():
            # Try to create a lexer instance
            temp_lexer = getattr(lexers, item)()
    form.display.repl_display_message(
        "No errors in lexer check.", 
        message_type=data.MessageType.SUCCESS
    )

def cyp_to_py():
    regex_replace_all(r"for\s+(\w+)\s*:=\s*(.*)\s+to\s+(.*)do",r"for \g<1> in range(\g<2>, (\g<3>)+1):",case_sensitive=False,window_name="Main")
    regex_replace_all(r"while\s+(.*)\s+do",r"while \g<1>:",case_sensitive=False,window_name="Main")
    regex_replace_all(r"if\s+(.*)=(.*)\s+then",r"if \g<1>==\g<2>:",case_sensitive=False,window_name="Main")
    regex_replace_all(r"((?<!=)(?<!\<)(?<!\>)(?<!:)(?!=)=)",r"==",case_sensitive=False,window_name="Main")
    replace_all(" then",":",case_sensitive=False,window_name="Main")
    replace_all("<>","!=",case_sensitive=False,window_name="Main")
    replace_all(":=","=",case_sensitive=False,window_name="Main")
    replace_all(";","",case_sensitive=False,window_name="Main")
    replace_all("end_for","",case_sensitive=False,window_name="Main")
    replace_all("end_if","",case_sensitive=False,window_name="Main")
    replace_all("end_while","",case_sensitive=False,window_name="Main")
    replace_all("elsif","elif",case_sensitive=False,window_name="Main")
    replace_all("else","else:",case_sensitive=False,window_name="Main")
    replace_all("//","# ",case_sensitive=False,window_name="Main")
    replace_all(" mod "," % ",case_sensitive=False,window_name="Main")
    ll = []
    for l in cmain.line_list:
        leading_spaces = len(l) - len(l.lstrip())
        mod = (leading_spaces % data.tab_width)
        diff = (data.tab_width - mod)
        if diff < data.tab_width/2:
            ajd = (leading_spaces + diff) * " "
        else:
            ajd = (leading_spaces - mod) * " "
        ll.append(ajd + l.lstrip())
    cmain.line_list = ll

def find_assignments_in_code(code):
    if isinstance(code, str) == True:
        code = code.split("\n")
    assignees = []
    for line in code:
        if re.search("(?<![=,<,>,!])\s*=\s*(?!=)", line):
            assignee = line[:line.find('=')].strip()
            if not assignee in assignees:
                assignees.append(line[:line.find('=')].strip())
    for a in assignees:
        print(a)
            

