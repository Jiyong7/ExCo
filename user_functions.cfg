
# -*- coding: utf-8 -*-

"""
    Ex.Co. LICENSE :
        This file is part of Ex.Co..

        Ex.Co. is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        Ex.Co. is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with Ex.Co..  If not, see <http://www.gnu.org/licenses/>.


    PYTHON LICENSE :
        "Python" and the Python logos are trademarks or registered trademarks of the Python Software Foundation,
        used by Ex.Co. with permission from the Foundation


    Cython LICENSE:
        Cython is freely available under the open source Apache License


    PyQt4 LICENSE :
        PyQt4 is licensed under the GNU General Public License version 3
    PyQt Alternative Logo LICENSE:
        The PyQt Alternative Logo is licensed under Creative Commons CC0 1.0 Universal Public Domain Dedication


    Qt Logo LICENSE:
        The Qt logo is copyright of Digia Plc and/or its subsidiaries.
        Digia, Qt and their respective logos are trademarks of Digia Corporation in Finland and/or other countries worldwide.


    Tango Icons LICENSE:
        The Tango base icon theme is released to the Public Domain.
        The Tango base icon theme is made possible by the Tango Desktop Project.

    My Tango Style Icons LICENSE:
        The Tango Icons I created are released under the GNU General Public License version 3.


    Eric6 LICENSE:
        Eric6 IDE is licensed under the GNU General Public License version 3
    
    
    Nuitka LICENSE:
        Nuitka is a Python compiler compatible with Ex.Co..
        Nuitka is licensed under the Apache license.
"""

##  FILE DESCRIPTION:
##      Normal module with a special name that holds custom user functions/variables
##
##  NOTES:
##      Built-in special function escape sequence: "lit#"
##          (prepend it to escape built-ins like: cmain, set_all_text, lines, ...)

import os
import re
import data #These imports are optional, I added them here for clarity
import functions #These imports are optional, I added them here for clarity
import settings #These imports are optional, I added them here for clarity
from forms import * #Imported for less typing


data.tab_width = 4
data.terminal = "xterm"
data.EDGE_MARKER_COLUMN = 80

def rename_items_in_directory(search_string, 
                              replace_string,
                              regex=False,
                              directory=None):
    """
    Replace the search string in the file names in the selected directory
    """
    if directory == None:
        #'form' is a reference to the MainWindow object that contains useful functions
        directory = form._get_directory_with_dialog()
        if directory == "" or directory == None:
            print("Canceled")
            return
    dir = os.listdir(directory)
    if regex == False:
        for item in dir:
            if search_string in item:
                os.rename(
                    os.path.join(directory, item), 
                    os.path.join(directory, item.replace(search_string, replace_string))
                )
    else:
        compiled_re = re.compile(search_string)
        for item in dir:
            full_file_name = os.path.join(directory, item)
            replaced_name = re.sub(compiled_re, replace_string, full_file_name)
            if replaced_name != full_file_name:
                os.rename(full_file_name, replaced_name)
    print("DONE")
#Custom autocompletion
rename_items_in_directory.autocompletion = "rename_items_in_directory(\"search_string\",\"replace_string\",regex=False,directory=None)"


def delete_files_in_dir(extension=None, directory=None):
    """
    Delete all files with the selected file extension from the directory
    """
    if isinstance(extension, str) == False:
        print("File extension argument must be a string!")
        return
    if directory == None:
        directory = os.getcwd()
    elif os.path.isdir(directory) == False:
        return
    print("Deleting '{:s}' files in:".format(extension))
    print(directory)
    for file in os.listdir(directory):
        file_extension = os.path.splitext(file)[1].lower()
        if file_extension == extension or file_extension == "." + extension:
            os.remove(os.path.join(directory, file))
            print(" - deleted file: {:s}".format(file))
    print("DONE")
#Custom autocompletion
delete_files_in_dir.autocompletion = "delete_files_in_dir(extension=\"\", directory=None)"

        
def is_number(string):
    """Check if the string is a number (integer or float)"""
    try: 
        float(string)
        return True
    except ValueError:
        return False

def convert_to_4x_indentation(editor):
    """Convert indentation of a editor window to the 4-spaces convention"""
    line_list           = editor.line_list
    standard_spacing    = 4
    #Find the lowest indentation in the document
    base_spacing = 4
    for line in line_list:
        current_indentation = get_line_indentation(line)
        if current_indentation > 0 and current_indentation < base_spacing:
            base_spacing = current_indentation
    #Correct the spacing
    output_list = []
    for line in line_list:
        current_indentation = get_line_indentation(line)
        if current_indentation > 0:
            factor = current_indentation / base_spacing
            output_list.append(
                (int(factor * standard_spacing) * " ") + line[current_indentation:]
            )
        else:
            output_list.append(line)
    #Replace the line list in the editor with the new list
    editor.line_list = output_list
#Custom autocompletion
convert_to_4x_indentation.autocompletion = "convert_to_4x_indentation(cmain)"
    
def print_nim_forward_declarations():
    """
    Create and display the forward declarations for procedures/functions
    for the Nim programming language in the REPL MESSAGES tab
    """
    #Set the editor
    editor = cmain
    #Get the Nim nodes
    nim_nodes = functions.get_nim_node_tree(editor.text())
    #Check if forward declarations are needed
    if nim_nodes.procedures == []:
        form.display.repl_display_message(
            "No procedures in the document!", 
            message_type=global_module.MessageType.WARNING
        )
        return
    #Create the forward declarations
    forward_declerations = []
    for proc in nim_nodes.procedures:
        proc_name   = proc.name
        parameters  = ", ".join(proc.parameters)
        return_type = ""
        if proc.return_type != None:
            return_type = ": {:s}".format(proc.return_type)
        fd = "proc {:s}({:s}){:s}".format(proc_name, parameters, return_type)
        forward_declerations.append(fd)
    #Sort the declarations by name
    forward_declerations.sort()
    #Display the declarations
    form.display.repl_display_message(
        "namespace ForwardDeclarations:", 
        message_type=global_module.MessageType.SUCCESS
    )
    for declaration in forward_declerations:
        form.display.repl_display_message("    " + declaration)
#Custom autocompletion
print_nim_forward_declarations.autocompletion = "print_nim_forward_declarations()"

def remove_empty_lines():
    """Remove the empty lines from the current main window document"""
    ll = []
    for line in main.currentWidget().line_list:
        if line.strip() != "":
            ll.append(line)
    main.currentWidget().line_list = ll
    form.display.repl_display_message(
        "Empty lit#lines removed from main window document", 
        message_type=global_module.MessageType.SUCCESS
    )
#Custom autocompletion
remove_empty_lines.autocompletion = "remove_empty_lines()"

def xml_lexer_colors(html="black", tag="blue", attribute="red", single_string="magenta"):
    lexer = cmain.lexer()
    lexer.setColor(PyQt4.QtGui.QColor(html),0)
    lexer.setFont(PyQt4.QtGui.QFont('Courier', 10, weight=PyQt4.QtGui.QFont.Bold), 0)
    
    lexer.setColor(PyQt4.QtGui.QColor(tag),1)
    lexer.setFont(PyQt4.QtGui.QFont('Courier', 10, weight=PyQt4.QtGui.QFont.Bold), 1)
    
    lexer.setColor(PyQt4.QtGui.QColor(attribute),3)
    lexer.setFont(PyQt4.QtGui.QFont('Courier', 10, weight=PyQt4.QtGui.QFont.Bold), 3)
    
    lexer.setColor(PyQt4.QtGui.QColor(single_string),6)
    lexer.setFont(PyQt4.QtGui.QFont('Courier', 10, weight=PyQt4.QtGui.QFont.Bold), 6)
#Custom autocompletion
xml_lexer_colors.autocompletion = "xml_lexer_colors(html=\"black\", tag=\"blue\", attribute=\"red\", single_string=\"magenta\")"

def trim_whitespace():
    """Remove whitespace from back of every line in the main document"""
    ll = []
    for line in cmain.line_list:
        ll.append(line.rstrip())
    cmain.line_list = ll
trim_whitespace.autocompletion = "trim_whitespace()"
    
def align_indentation_to_cursor():
    """
    Align indentation of multiple lines to cursor, while keeping
    the current leading whitespace structure
    """
    start_line_number   = cmain.getSelection()[0] + 1
    end_line_number     = cmain.getSelection()[2] + 1
    smallest_line_space = 0
    #Get smallest indentation level
    for i in range(start_line_number, end_line_number+1):
        current_line_space = 0
        for char in line_list[i]:
            if char == " ":
                current_line_space += 1
            else:
                break
        if current_line_space < smallest_line_space or smallest_line_space == 0:
            smallest_line_space = current_line_space
    #Remove the smallest indentation level from selected lines
    new_lines = []
    for i in range(start_line_number, end_line_number+1):
        new_lines.append(line_list[i][smallest_line_space:])
    #Add the whitspaces to the current cursor position to every selected line_count
    padding = " " * cmain.getCursorPosition()[1]
    for i in range(0, len(new_lines)):
        new_lines[i] = padding + new_lines[i]
    #Finally, replace the lines
    line_list[start_line_number:end_line_number] = new_lines
align_indentation_to_cursor.autocompletion = "align_indentation_to_cursor()"

def align_nim_type_declerations():
    """Align indentation of Nim programming language type declarations"""
    start_line_number   = cmain.getSelection()[0] + 1
    end_line_number     = cmain.getSelection()[2] + 1
    line_indentation    = 0
    #Find indentation level by using the first line
    common_indentation = " " * (len(line_list[start_line_number]) - len(line_list[start_line_number].lstrip()))
    #Get largest indentation level between the var name and type
    largest_item_column = 0
    for i in range(start_line_number, end_line_number+1):
        split_line = line_list[i].split(":")
        #Check line structure
        if len(split_line) < 2:
            form.display.repl_display_message(
                "Inconsistent line structure in line: {:d}".format(i), 
                message_type=global_module.MessageType.ERROR
            )
            return
        elif not(":" in line_list[i]):
            form.display.repl_display_message(
                "Colon has to be right behind the variable name in line: {:d}".format(i), 
                message_type=global_module.MessageType.ERROR
            )
            return
        current_item_column = len(common_indentation) + len(split_line[0].strip()) + len(": ")
        if current_item_column > largest_item_column:
            largest_item_column = current_item_column
    #Pad all lines to the largest second item column
    replacement_list = []
    for i in range(start_line_number, end_line_number+1):
        split_line = line_list[i].split(":")
        colon_index = line_list[i].find(":") + 1
        line_beginning = (common_indentation + split_line[0].strip() + ": ").ljust(largest_item_column)
        line_end = line_list[i][colon_index:].lstrip()
        replacement_list.append(line_beginning + line_end)
    #Replace the range
    line_list[start_line_number:end_line_number] = replacement_list
align_nim_type_declerations.autocompletion = "align_nim_type_declerations()"

def NEP1():
    """Python/C to Nim coding convention conversion"""
    try:
        text = cmain.selectedText()
        if len(text.split("_")) < 2:
            return
        split_text = text.split("_")
        split_text[0] = split_text[0].lower()
        if split_text[0].startswith("py") and len(split_text[0]) > 2:
            split_text[0] = split_text[0][:2] + split_text[0][2].upper() + split_text[0][3:]
        if len(split_text) > 1:
            for i in range(1, len(split_text)):
                split_text[i] = split_text[i][0].upper() + split_text[i][1:]
        replacement = "".join(split_text)
        result = "{{.deprecated: [{:s}: {:s}].}}".format(text, replacement)
        replace_in_selection(text,replacement,case_sensitive=True,window_name="Main")
#        line_list.insert(cmain.get_line_number()+1, "  " + result)
    except Exception as ex:
        print(str(ex))
#    cmain.set_first_visible_line(cmain.get_line_number()-20)
    print(result)
NEP1.autocompletion = "NEP1()"

def NEP1_proc(fr, to):
    """Python/C to Nim coding convention conversion for procedures"""
    try:
        ll = []
        for i in range(fr, to):
            text = cmain.line_list[i]
            if len(text.split("_")) < 2 or not text.startswith("proc"):
                return
            proc_name = text[5:text.find("*(")]
            split_text = proc_name.split("_")
            split_text[0] = split_text[0].lower()
            if split_text[0].startswith("py") and len(split_text[0]) > 2:
                split_text[0] = split_text[0][:2] + split_text[0][2].upper() + split_text[0][3:]
            if len(split_text) > 1:
                for i in range(1, len(split_text)):
                    split_text[i] = split_text[i][0].upper() + split_text[i][1:]
            replacement = "".join(split_text)
#            print(proc_name + " > " + replacement)
            result = text.replace(proc_name, replacement)
            result = result.replace("importc,", 'importc: "{:s}"'.format(proc_name))
            ll.append(result)
            ll.append("{{.deprecated: [{:s}: {:s}].}}".format(proc_name, replacement))
        # Replace the modified lines
        cmain.line_list.insert(to, "\n".join(ll))
    except Exception as ex:
        print(str(ex))
NEP1.autocompletion = "NEP1_proc()"

def NEP1_lines(fr, to):
    """Python/C to Nim coding convention conversion for lines"""
    for i in range(fr, to):
        if line_list[i].strip().startswith("#"):
            continue
#        cmain.setSelection(i-1,2,i-1,line_list[i].find("*"))
        cmain.setSelection(i-1,2,i-1,line_list[i].find(" = cast"))
        NEP1()
NEP1_lines.autocompletion = "NEP1_lines(,)"
